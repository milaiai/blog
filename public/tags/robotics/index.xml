<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Robotics on MILAI AI</title>
    <link>//localhost:1313/tags/robotics/</link>
    <description>Recent content in Robotics on MILAI AI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 10 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="//localhost:1313/tags/robotics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Agent引擎的实现</title>
      <link>//localhost:1313/post/ch3.2.5-6-agent-%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch3.2.5-6-agent-%E5%BC%95%E6%93%8E%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>Angent的实现
Overview 之前学习了状态迁移函数，并能绘制机器人。
这节的目标是实现机器人的引擎，让机器人能动起来。
笔记  ロボットの制御指令を決めるエージェントのクラスを作ります。 「考え主体」のことを、ロボチックスや人工知能の研究分野ではエージェントと呼びます。 今の段階ではただ一定自家ごとに固定値の$\nu, \omega$を返すというもとにします。 hasattrは、オブジェクトにメソッドがあるかを調べる関数です。 何秒間シミュレーションするか(time_span) と$\Delta t$ (time_interval)を指定できるようにします。  理论  机器人通过机器人来发布控制指令。 控制指令： $\nu = (\nu, \omega)^\top$ 设定仿真时长(time_span)，第帧的时间间隔(time_interval) 帧数 = time_span/time_interval hasattr用来检查对象是否存在  Sample Code # -*- coding: utf-8 -*- &amp;#34;&amp;#34;&amp;#34;ch3 robot model Automatically generated by Colaboratory. Original file is located at https://colab.research.google.com/drive/1s6LUufRD3f70hqtnyt9tsTqXnEJN7QL1 &amp;#34;&amp;#34;&amp;#34; # Commented out IPython magic to ensure Python compatibility. # %matplotlib inline import matplotlib.pyplot as plt import matplotlib.patches as patches import math import numpy as np # Animation import matplotlib matplotlib.</description>
    </item>
    
    <item>
      <title>机器人位姿描述</title>
      <link>//localhost:1313/post/ch3.1-%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%8D%E5%A7%BF%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch3.1-%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%8D%E5%A7%BF%E6%8F%8F%E8%BF%B0/</guid>
      <description>Objective  绘制世界坐标系 如何描述机器人的位姿 如何绘制世界坐标系 如何绘制机器人位姿  可参考：3.2.2 ロボットの姿勢と描く
対向２輪ロボット(Differential wheeled robot) 机器人位姿   世界坐标系记为 $\Sigma_{world}$
  位姿 (状态)：位置和朝向 $x = (x, y, \theta)^T$
  状态空间： 姿势（状态）的集合
  位姿x所有可能的取值的集合$\chi$，例如平面上的长方形的范围内自由移动的机器人位姿的状态空间为：
$$ \chi = { x=(x, y, \theta)^T | x \in [x_{min}, x_{max}], y \in [y_{min}, y_{max}], \theta \in [- \pi, \pi) } $$
Source Code import matplotlib.pyplot as plt import matplotlib.patches as patches import math import numpy as np class World: def __init__(self): self.</description>
    </item>
    
    <item>
      <title>机器人开发环境介绍</title>
      <link>//localhost:1313/post/ch1-environment/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch1-environment/</guid>
      <description>机器人开发环境介绍 In this section, we will tintroduce:
 the usage case of robots the development environment for simulation (Python + conda)  概率机器人详解 概率机器人详解 Homepage
课件: ryuichiueda/LNPR_SLIDES
原书代码: ryuichiueda/LNPR_BOOK_CODES
My source code: https://github.com/yubaoliu/Probabilistic-Robotics.git
Robot Introduction Soccer match:
Human support robot:
Note: you can find these videos on https://space.bilibili.com/52620240 too.
Environment Deployment  (optional) Anyconda or other virtual Python environment Jupyter notebook  You can refer https://www.ybliu.com/2021/01/OpenCV-Python-Development.html to deploy a conda-based development environment.</description>
    </item>
    
    <item>
      <title>机器人概率基础</title>
      <link>//localhost:1313/post/ch2-probabilistics/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch2-probabilistics/</guid>
      <description>平均値 $$\mu = \frac{1}{N}\sum_{i=0}^{N-1} z_i$$
 $z_0, z_1, \dots, z_{N-1}$: センサ値 $N$: センサ値の個数  分散、標準偏差 $$\sigma^2 = \frac{1}{N-1}\sum_{i=0}^{N-1} (z_i - \mu)^2 \quad (N&amp;gt;1)$$
(素朴な）確率分布 ここでやりたいこと: 度数分布から、 未来にどんなセンサ値が得られそうかを予想
 ただし、集める個数によって値が変わってはいけないので度数分布を頻度でなく割合に * $P_{\textbf{z}\text{LiDAR}}(z) = N_z / N$　（$N_z$: センサの値が$z$だった頻度） * 全センサ値の種類に関して$P_{\textbf{z}\text{LiDAR}}(z)$を足し合わせると1に $P_{\textbf{z}\text{LiDAR}}(z)$を確率と呼びましょう  Samples draw:
$$ z \sim P_{\textbf{z}\text{LiDAR}} $$
Probabilistic Model ガウス分布の当てはめ
连续的情况 $$ p(z | \mu, \sigma^2 ) = \frac{1}{\sqrt{2\pi}\sigma} e^{ - \frac{(z - \mu)^2}{2\sigma^2}} $$
$$ p(x | \mu, \sigma^2 ) $$</description>
    </item>
    
    <item>
      <title>用动画来绘制Robot仿真环境</title>
      <link>//localhost:1313/post/ch3.2.3-%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%8D%E5%A7%BF%E5%8A%A8%E7%94%BB%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch3.2.3-%E6%9C%BA%E5%99%A8%E4%BA%BA%E4%BD%8D%E5%A7%BF%E5%8A%A8%E7%94%BB%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>Objective  用动画来绘制Robot仿真环境  重要函数 matplotlib.animation.FuncAnimation class matplotlib.animation.FuncAnimation(fig, func, frames=None, init_func=None, fargs=None, save_count=None, *, cache_frame_data=True, **kwargs)[source]  intervalnumber, optional Delay between frames in milliseconds. Defaults to 200. frames iterable, int, generator function, or None, optional fargstuple or None, optional Additional arguments to pass to each call to func.  Refer https://matplotlib.org/api/_as_gen/matplotlib.animation.FuncAnimation.html for detail.
matplotlib.pyplot.plo  https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot  matplotlib.pyplot.plot(*args, scalex=True, scaley=True, data=None, **kwargs) 注意其返回值为： lines A list of Line2D objects representing the plotted data.</description>
    </item>
    
    <item>
      <title>绘制Landmark</title>
      <link>//localhost:1313/post/ch3.3.1-%E7%BB%98%E5%88%B6landmark/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch3.3.1-%E7%BB%98%E5%88%B6landmark/</guid>
      <description>绘制地图点
Overview 概率机器人详解 （Python） 3.3.1　点ランドマークの設置
 本文将介绍：
 Landmark 是什么 如何绘制Landmark 实现Landmark 类与Map类的框架   理论  地标： $m = { m_j|j=0, 1,2,&amp;hellip;, N_m-1 }$ 总共 $N_m$个。 地图：记录所有地标的位置。 地标 $m_j$: 在世界坐标系下的座标表示为: $m_j = ( m_{j,x}, m_{j,y} )$.  关键代码 Landmark class:
class Landmark: def __init__(self, x, y): self.pos = np.array([x, y]).T self.id = None def draw(self, ax, elems): c = ax.scatter(self.pos[0], self.pos[1], s=100, marker=&amp;#34;*&amp;#34;, label=&amp;#34;landmarks&amp;#34;, color= &amp;#34;orange&amp;#34;) elems.append(c) elems.append(ax.text(self.pos[0], self.</description>
    </item>
    
    <item>
      <title>观测方程</title>
      <link>//localhost:1313/post/ch3.3-%E8%A7%82%E6%B5%8B%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch3.3-%E8%A7%82%E6%B5%8B%E6%96%B9%E7%A8%8B/</guid>
      <description>観測方程式 $$ \begin{pmatrix} \ell_j \\ \varphi_j \end{pmatrix} = \begin{pmatrix} \sqrt{(m_{j,x} - x)^2 + (m_{j,y} - y)^2} \\ \text{atan2}(m_{j,y} - y, m_{j,x} - x) - \theta \end{pmatrix} $$
 $z_j = h_j (x)$ $z_j = h(x, m_j)$（ランドマークの位置を変数とする場合） 関数$h_j$: 観測関数  参考代码 class IdealCamera: def __init__(self, env_map, \ distance_range=(0.5, 6.0), direction_range=(-math.pi/3, math.pi/3)): self.map = env_map self.lastdata = [] self.distance_range = distance_range self.direction_range = direction_range def visible(self, polarpos): if polarpos is None: return False return self.</description>
    </item>
    
    <item>
      <title>运动方程</title>
      <link>//localhost:1313/post/ch3.2.4-%E8%BF%90%E5%8A%A8%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/ch3.2.4-%E8%BF%90%E5%8A%A8%E6%96%B9%E7%A8%8B/</guid>
      <description>内容  运动方程， 控制命令， 让机器人动起来。  理论 (Refered From: https://github.com/ryuichiueda/LNPR_SLIDES/blob/master/old_version/figs/robot_motion1.png)
 (Refered From: https://github.com/ryuichiueda/LNPR_SLIDES/raw/master/old_version/figs/robot_motion2.png)
相关变量  速度: $nv [m/s]$ 角速度： $\omega [rad/s]$ 制御指令：从 $t-1$ 时刻到$t$时刻的运动指令 $u_t = (\nu_t, \omega_t)$   制御指令（せいぎょしれい）は離散時刻ごとにしか変えられないことにします。時刻$t-1$からt までの制御指令を$u_t = (\nu_t, \omega_t)$ と表記します。
u 是相对于机器人的，那么其在世界坐标系下的速度应该如何表示。
$$ \begin{pmatrix} \dot{x} \
\dot{y} \\ \dot{\theta} \end{pmatrix} = \begin{pmatrix} \nu\cos\theta \
\nu\sin\theta \
\omega \end{pmatrix} $$
从t-1时刻到t时刻的角度变化：
$$ \theta_t = \theta_{t-1} + \int_{0}^{\delta t} \omega_t dt = \theta_{t-1} + \omega_t \Delta t $$</description>
    </item>
    
  </channel>
</rss>