<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on MILAI AI</title>
    <link>//localhost:1313/tags/algorithm/</link>
    <description>Recent content in Algorithm on MILAI AI</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 10 Mar 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="//localhost:1313/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>算法-动态规划</title>
      <link>//localhost:1313/post/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>在线测试  https://www.luogu.com.cn/ https://onlinejudge.org/ https://leetcode-cn.com/  动态规划 斐波那契数 斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：
F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n &amp;gt; 1 给你 n ，请计算 F(n) 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/fibonacci-number
示例：
输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 示例代码：
int fib(int n) { int F[n+1]; F[0] = 0; if (n &amp;lt;= 0) return F[0]; F[1] = 1; if (n == 1) return F[1]; for (int i = 2; i &amp;lt; n+1; i++) { F[i] = F[i - 1] + F[i - 2]; } return F[n]; } 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</description>
    </item>
    
    <item>
      <title>算法-最短路径</title>
      <link>//localhost:1313/post/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/post/%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>最短路径 Dijkstra 算法 基于贪心的单源最短路算法，其要求图中的边全部非负。
  Dijkstra’s shortest path algorithm
  戴克斯特拉算法-wiki
  算法描述 procedure Dijkstra(G：边全为正权的图） 2 {G带有顶点 $a=v_{0},v_{1},v_{2}&amp;hellip;$}和若干边 $w(v_{i},v_{j})$ 3 for i:=1 to n 4 $D(v_{i}):=\infty $ 5 D(a):=0 6 $S:=\emptyset$ 7 while $z\notin S$ 8 begin 9 u:=不属于S的D(u)最小的一个顶点 10 $S:=S\cup {u}$ 11 for 所有不属于S的顶点v 12 if D(u)+w(u,v)&amp;lt;D(v) then D(v):=D(u)+w(u,v) 13 end{D(z)=从a到z的最短路长度}
使用优先队列
1 function Dijkstra(G, w, s) 2 INITIALIZE-SINGLE-SOURCE(G, s) //实际上的操作是将每个除原点外的顶点的d[v]置为无穷大，d[s]=0 3 $S\leftarrow \emptyset$ 4 $Q\leftarrow s$ // Q是顶点V的一个优先队列，以顶点的最短路径估计排序 5 while( $Q\not =\emptyset $) 6 do $u\leftarrow EXTRACT-MIN(Q)$ //选取u为Q中最短路径估计最小的顶点 7 $S\leftarrow S\cup u$ 8 for each vertex $v \in Adj[u]$ 9 do RELAX(u, v, w) //松弛成功的结点会被加入到队列中</description>
    </item>
    
  </channel>
</rss>